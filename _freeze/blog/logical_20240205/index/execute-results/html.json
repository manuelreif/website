{
  "hash": "aab0cb228167986e5bbb2cae8c2d4876",
  "result": {
    "markdown": "---\ntitle: \"Logical\"\ndescription: \"Logicals sind ein hervorragender Zeitvertreib, insbesondere wenn sie mit Mixed Integer Programming und Python gelöst werden.\"\nauthor: Manuel Reif \ndate: 2024-02-05\ncategories: [Python, OR]\ndraft: false \nhighlight-style: monokai\nimage: media/memes/logical_brain.jpg\n---\n\n\n\n\n<img src=\"media/pm_header.jpg\" alt=\"Logiktrainer Frontpage\" style=\"float: right; width: 45%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nWenn ich mit dem Zug fahre vergeht die Zeit am schnellsten wenn ich versuche Rätsel\nzu lösen. Dann investiere ich mein Geld in den P. M. Logik Trainer, nehme mir sehr\nviel vor und es endet meist damit, dass das erste Rätsel mich so lang beschäftigt\ndass ich zu keinem Weiteren komme. Manchmal sind die Rätsel auch so schwierig,\ndass ich keine Lösung finde. Also bleibt das gekaufte Heft immer zum größten Teil\nunausgefüllt. Weihnachten 2023 packte mich der Ehrgeiz und ich wollte in einer\nruhigen Stunde, ein sogenanntes Logical lösen, das zuvor auf einer Zugfahrt \nungelöst blieb. Doch obwohl Weihnachten ein Fest der Liebe ist, wurde es\nob dieses Logicals beinahe ein Fest des Hasses, denn es wollte sich nicht lösen\nlassen obwohl ich bereits mehr als 10 Minuten investiert hatte.\n\nDer Gedanke, das Problem mittel Optimierung zu lösen kam sehr rasch nach der\nErkenntnis dass es sich eigentlich lösen lassen müsste.\n\n\n# Das Problem\n\n\n\n::::{.columns}\n\n:::{.column width=\"47%\"}\n\nDas zu lösende Problem sieht folgendermaßen aus:\nEs werden beliebige Wörter, in diesem Fall Namen von Bands genannt. Jedes Wort\nist einer Zahl zugeordnet. Diese Zahl bezeichnet die Summe der Buchstabenwerte.\nAlso z. B. wissen wir laut nebenstehender Tabelle, dass `A + C + D + C = 45`.\nZiel ist es, die Buchstabenwerte herauszufinden. Die einzigen bekannten Informationen\nsind:\n\n1. Die **Summe** der Buchstaben jedes Wortes\n2. Jedem Buchstaben ist genau eine Zahl zwischen 1 und 26 zugeordnet\n3. Zwei Buchstaben haben nie dieselbe Zahl -- also es werden für 26 Buchstaben\nalle Zahlen von 1-26 zugeordnet.\n\n\n\n:::\n\n:::{.column width=\"4%\"}\n\n\n\n\n:::\n\n:::{.column width=\"47%\"}\n\n\n\n::: {.cell tbl-cap='Bandnamen und deren zugehörige Buchstabensumme'}\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-3358082b261b66e24a6f\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-3358082b261b66e24a6f\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"caption\":\"<caption>Bandnamen und deren zugehörige Buchstabensumme<\\/caption>\",\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\"],[\"acdc\",\"beatles\",\"coldplay\",\"deep purple\",\"dire straits\",\"eagles\",\"genesis\",\"jethro tull\",\"led zeppelin\",\"lynyrd skynyrd\",\"metallica\",\"nirvana\",\"oasis\",\"pink floyd\",\"queen\",\"rolling stones\",\"steppenwolf\",\"styx\",\"uriah heep\",\"van halen\"],[45,52,62,27,82,29,47,97,55,126,87,75,43,92,44,103,91,60,78,88]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>Bands<\\/th>\\n      <th>Buchstabensumme<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"pageLength\":7,\"bFilter\":0,\"dom\":\"ftp\",\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":2},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false,\"lengthMenu\":[7,10,25,50,100]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n\n:::\n\n::::\n\nNormalerweise beginnt man nun damit Wörter die es einem leicht machen einzelne \nBuchstabenwerte zu identifizieren. Das können möglichst kurze Wörter sein, \noder auch Wörter mit besonders niedrigen Buchstabensummen. \nOft gibt es dazu eine Einstiegshilfe, in Form eines Hinweises, welches Wort sich \nbesonders gut eignet.\n\n# Die Suche\n\n\n<img src=\"media/memes/logical_brain.jpg\" alt=\"My brain when solving a logical\" style=\"float: right; width: 55%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nDas klingt alles sehr mühsam -- und ok, wenn man es dann gelöst hat stellt\nsich eine gewisse Zufriedenheit ein. Aber auf dem Weg dorthin erlebt man zahlreiche\nFrustrationen. Ich weiß nicht wie es euch geht, aber in meiner Freizeit lasse ich\nmich ungern frustrieren. Man will aber das Problem ja auch nicht ungelöst im Heft lassen.\nWobei das wirkliche Problem ja nicht der \"Ungelöst\" Status des Problems ist, sondern\nvielmehr dass man es probiert hat um dann zu dem Schluss zu kommen es \n\"aus persönlichen Gründen\" doch nicht zu lösen. \nDas Problem wird zum Problem. Es prangt regelrecht wie ein frisch errichtetes \nDenkmal des eigenen Scheiterns.\nSelbst wenn das Heft geschlossen auf dem Tisch liegt, dringt es hindurch und \nerinnert uns daran, dass die \"persönlichen Gründe\" spezifischer formuliert,\nnichts anderes als das das eigene Unvermögen bezeichnen.\nDie Denkmalhaftigkeit hat sich inzwuschen auch auf das gesamte Heft übertragen\nund droht omnipräsent zu werden und uns bis ins Mark zu erschüttern. Um diesen\nProzess zu unterbrechen ergibt sich die Notwendigkeit das Rätsel zu lösen auch\nwenn man dafür (ein bissi) Python lernen muss.\n\nAber an diesem Punkt war ich noch lange nicht. Ich begann damit, in altem Wissen\nzu kramen aus längst vergangenen Tagen als ich mich noch mit Dingen wie \n\"integer programming\" beschäftigen durfte. Das war unterhaltsam. Man musste doch\neine Lösung finden auf eine ähnliche Art wie ich damals eine Lösung gefunden habe\nmit `SCIP` und `ZIMPL.` Das war die erste Station. Und es war keine gute Station.\nAuf der Achterbahnfahrt durch den kleinen Optimierungs-Horrorladen gab es noch \neinige weitere Stationen wie z. B. das `ompr` package, das mir einfach bei meinem\nProblem nicht helfen konnte. Ich bin sicher, dass es viele Menschen gibt die\ndieses Package mit Freude verwenden, wo es gute Ergebnisse liefert und \nalle glücklich macht. Doch es war einfach nicht das richtige für mich. Es \ngab kein Kribbeln. Zumindest kein gutes.\n\nUm einmal zu wissen wonach man sucht, versuchen wir mal die Nebenbedingungen zu\ndefinieren. \n\n\n## Buchstabensumme \n\nDie erste Nebenbedingung ist die offensichtlichste, da sie explizit gegeben ist.\nWie schon oben beschrieben ist jeweils die Summe der Buchstabe der einzelnen\nWörter gegeben. Man kann sich das ganze auch als eine Matrix vorstellen: Jede\nSpalte stellt einen Buchstaben dar (wie unten in der $n \\times l$ Matrix). \nDie erste Spalte ist **a** die zweite\nSpalte **b** und so weiter. Beim ersten Wort **ACDC** sehen wir eine **1** \nin der ersten Spalte (A), eine **2** in der dritten Spalte (C) und wieder eine\n**1** in der vierten Spalte (D) $\\rightarrow$ zusammen \nACDC^[oder ACCD -- beim Summieren ist die Reihenfolge ja völlig egal.]. \nJede Zeile stellt ein Wort, in diesem konkreten Fall eine Band dar.\nD. h. wir haben **n Wörter** und **l Buchstaben**^[Das sind immer 26 Buchstaben. Also könnte man auch 26 schreiben. Aber mit **l** schaut es viel cooler aus.].\nMultipliziert wird diese Matrix mit einem Vektor $\\vec{\\theta}$. Dieser beinhalten\ndas was man wissen will: die Werte der einzelnen Buchstaben. $\\theta_a$ ist \nder Wert den Buchtabe **a** hat. Die Werte kennen wir nicht. Das ultimative\nZiel ist es sie zu ermitteln. Wenn wir die $n \\times l$ Matrix mit $\\vec{\\theta}$\nmultiplizieren, muss die vorgegeben Summe rauskommen. Das sind genau die \nSummen die im Logical vorgegeben sind: Für **ACDC** z. B. **45**.\nDas schaut alles mega kompliziert aus. Das ist aber noch die netteste Nebenbedngung.\nDie kann ich auch an `SCIP` verfüttern. Aber die kommende Nebenbedingung ist\nschon schwieriger umzusetzen^[Vor allem wenn man eben ein Tool verwendet, das man eigentlich für ein solches Problem nicht verwenden sollte.].\n\n\\begin{align}\n\n\\begin{bmatrix}\n  1 & 0 & 2 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  1 & 1 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  0 & 0 & 0 & 1 & 3 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 2 & 0 & \\ldots \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\\\\n\\end{bmatrix}\n\n_{n \\times l} \\times \\quad \\begin{bmatrix}\n   \\theta_a  \\\\\n   \\theta_b \\\\\n   \\theta_c \\\\\n   \\theta_d \\\\\n   \\theta_e \\\\\n   \\vdots\n\\end{bmatrix}_{l \\times 1} = \\quad\n\\begin{bmatrix}\n   45  \\\\\n   52 \\\\\n   62 \\\\\n   27 \\\\\n   82 \\\\\n   \\vdots\n\\end{bmatrix}_{l \\times 1}\n\\end{align}\n\n\n## Verschiedene Elemente\n\n<img src=\"media/memes/worst_constraint.jpg\" alt=\"My brain when solving a logical\" style=\"float: right; width: 35%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nWenn man sich obenstehende Tabelle ansieht, dann merkt man, dass man 26 Buchstaben\nhat, aber nur 20 Nebenbedingungen. Daher kann das nicht alles sein. Es darf nicht\nalles sein, wenn wir das hier lösen wollen. Die implizite Nebenbedingung ist, dass\njeder Buchstabe eine eigene Zahl zwischen 1 und 26 bekommen soll. Keine zwei\nElemente dürfen ident sein. Also etwas formeller angeschrieben sieht das ca. so aus:\n\n\n\\begin{align}\n1 \\leq \\theta_i \\leq 26, & \\quad i = a, b, \\ldots, z, \\\\\n\\theta_i \\neq \\theta_j, & \\quad \\forall i, j \\in \\{a, b, \\ldots, z\\}, i \\neq j.\n\\end{align}\n\nDie Suche nach einer Lösung mittels Integer Programming war noch unlustiger\nals das Ganze per Hand zu lösen. Für solche Fragen konsultiere ich normalerweise\nmein Optimierungs-Orakel -- so auch dieses Mal. \n\n\n\n# Die Lösung\n\n<!--\n- Download machen für das .py file\n- auf csv umstellen\n- download machen für das csv file\n- verweis zu harri machen\n-->\n\nWir brauchen folgende Ingredienzien:\n\n1. Ein Excel File in dem das jeweilige Wort und die die Wortsumme gespeichert ist\n2. Python installiert samt: `numpy`, `pandas`, `os`, `string`, `pyexcel_ods3` und \n`ortools.sat.python`\n3. Die Funktion `solve_logical()`\n\n\n## Buchstabenmatrix erstellen\n\n\n## \n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.28/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.4/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.4/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.4/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}