{
  "hash": "e1b55935fee0022913c414e43fbef6dc",
  "result": {
    "markdown": "---\ntitle: \"Logical\"\ndescription: \"Logicals sind ein hervorragender Zeitvertreib, insbesondere wenn sie mit Google OR-Tools und Python gelöst werden.\"\nauthor: Manuel Reif \ndate: 2024-02-10\ncategories: [Python, OR-Tools, docker]\ndraft: false \nhighlight-style: monokai\nimage: media/memes/logical_brain.jpg\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n---\n\n\n\n::: {.callout-tip icon=false}\n## {{< bi book-half size=25px >}} Soll ich lesen?\n1. Liebst du Rätsel? <br>\n2. Findest du Optimierung cool? <br>\n3. Findest du Python zumindest ok? <br>\n$\\rightarrow$ Dann **Lesebefehl!**\n:::\n\n\n<img src=\"media/pm_header.jpg\" alt=\"Logiktrainer Frontpage\" style=\"float: right; width: 45%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nWenn ich mit dem Zug fahre vergeht die Zeit am schnellsten wenn ich versuche Rätsel\nzu lösen. Dann investiere ich mein Geld in den [P. M. Logik Trainer](https://www.verlagshaus24.at/pm-logik-trainer-vorteilsabo/)^[Ich werde (leider) nicht gesponsert von P. M.!], nehme mir sehr\nviel vor und es endet meist damit, dass das erste Rätsel mich so lang beschäftigt\ndass ich zu keinem Weiteren komme. Manchmal sind die Rätsel auch so schwierig,\ndass ich keine Lösung finde. Also bleibt das gekaufte Heft immer zum größten Teil\nunausgefüllt. Weihnachten 2023 packte mich der Ehrgeiz und ich wollte in einer\nruhigen Stunde, ein sogenanntes Logical lösen, das zuvor auf einer Zugfahrt \nungelöst blieb. Doch obwohl Weihnachten ein Fest der Liebe ist, wurde es\nob dieses Logicals beinahe ein Fest des Hasses, denn es wollte sich nicht lösen\nlassen obwohl ich bereits mehr als 10 Minuten investiert hatte.\n\n\nEs ungelöst zu lassen war keine Option. Das würde scheitern bedeuten -- und \nscheitern ist keine Option. Also musste ich mit dem schweren Werkzeug ran. \nIch kramte in meinem Gedächtnis und in meinen Ordnern um mich an die Tools zu erinnern\nmit denen ich im Studium zu tun hatte. Spoileralarm: Diese Tools brachten mich\nnicht zum Erfolg -- dafür durfte ich was neues lernen!\n\n\n# Das Problem\n\n\n\n::::{.columns}\n\n:::{.column width=\"47%\"}\n\nDas zu lösende Problem sieht folgendermaßen aus:\nEs werden beliebige Wörter, in diesem Fall Namen von Bands genannt. Jedes Wort\nist einer Zahl zugeordnet. Diese Zahl bezeichnet die **Summe** der Buchstabenwerte.\nAlso z. B. wissen wir laut nebenstehender Tabelle, dass `A + C + D + C = 45`.\nZiel ist es, die Buchstabenwerte herauszufinden. Die einzigen bekannten Informationen\nsind:\n\n1. Die **Summe** der Buchstaben jedes Wortes\n2. Jedem Buchstaben ist genau eine Zahl zwischen 1 und 26 zugeordnet.\n3. Zwei Buchstaben haben nie dieselbe Zahl -- also es werden für 26 Buchstaben\nalle Zahlen von 1-26 zugeordnet.\n\n\n\n:::\n\n:::{.column width=\"4%\"}\n\n\n\n\n:::\n\n:::{.column width=\"47%\"}\n\n\n\n::: {.cell tbl-cap='Bandnamen und deren zugehörige Buchstabensumme'}\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-d0725bc1f614b6f10c84\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-d0725bc1f614b6f10c84\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"caption\":\"<caption>Bandnamen und deren zugehörige Buchstabensumme<\\/caption>\",\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\"],[\"acdc\",\"beatles\",\"coldplay\",\"deep purple\",\"dire straits\",\"eagles\",\"genesis\",\"jethro tull\",\"led zeppelin\",\"lynyrd skynyrd\",\"metallica\",\"nirvana\",\"oasis\",\"pink floyd\",\"queen\",\"rolling stones\",\"steppenwolf\",\"styx\",\"uriah heep\",\"van halen\"],[45,52,62,27,82,29,47,97,55,126,87,75,43,92,44,103,91,60,78,88]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>Bands<\\/th>\\n      <th>Buchstabensumme<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"pageLength\":7,\"bFilter\":0,\"dom\":\"ftp\",\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":2},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false,\"lengthMenu\":[7,10,25,50,100]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n\n:::\n\n::::\n\nNormalerweise beginnt man nun damit bei Wörtern die es einem leicht machen einzelne \nBuchstabenwerte zu identifizieren. Das können möglichst kurze Wörter sein, \noder auch Wörter mit besonders niedrigen Buchstabensummen. \nOft gibt es dazu eine Einstiegshilfe, in Form eines Hinweises, welches Wort sich \nbesonders gut eignet.\n\n# Die Suche\n\n\n<img src=\"media/memes/logical_brain.jpg\" alt=\"My brain when solving a logical\" style=\"float: right; width: 55%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nDas klingt alles sehr mühsam -- und ok, wenn man es dann gelöst hat stellt\nsich eine gewisse Zufriedenheit ein. Aber auf dem Weg dorthin erlebt man zahlreiche\nFrustrationen. Ich weiß nicht wie es euch geht, aber in meiner Freizeit lasse ich\nmich ungern frustrieren. Man will aber das Problem ja auch nicht ungelöst im Heft lassen.\nWobei das wirkliche Problem ja nicht der \"Ungelöst\" Status des Problems ist, sondern\nvielmehr dass man es probiert hat um dann zu dem Schluss zu kommen es \n\"aus persönlichen Gründen\" doch nicht zu lösen. \nDas Problem wird zum Problem. Es prangt regelrecht wie ein frisch errichtetes \nDenkmal des eigenen Scheiterns.\nSelbst wenn das Heft geschlossen auf dem Tisch liegt, dringt es hindurch und \nerinnert uns daran, dass die \"persönlichen Gründe\" spezifischer formuliert,\nnichts anderes als das das eigene Unvermögen bezeichnen.\nDie Denkmalhaftigkeit hat sich inzwischen auch auf das gesamte Heft übertragen\nund droht omnipräsent zu werden und uns bis ins Mark zu erschüttern. \nDaher wird es jetzt gelöst auch wenn wir uns dafür (ein bissi) mit Python \nauseinandersetzen müssen.\n\nAber an diesem Punkt war ich noch lange nicht. Ich begann damit, in altem Wissen\nzu kramen aus längst vergangenen Tagen, als ich mich (im Studium) noch mit Dingen wie \nInteger Programming beschäftigen durfte. Das war unterhaltsam. Die Tools schienen\nmächtig, als könnten sie alle Probleme der Welt lösen wenn man ihnen nur genügend\nZeit ließe. Ich googlete nach den neuesten Informationen zu [SCIP](https://www.scipopt.org/) und [ZIMPL](https://zimpl.zib.de/index.php#download). Das war die erste Station. \nUnd es war keine gute Station. Auf der Achterbahnfahrt durch den kleinen Optimierungs-Horrorladen gab es noch einige weitere Stationen wie z. B. das `ompr` package, das mir einfach bei meinem\nProblem nicht helfen konnte. Ich bin sicher, dass es viele Menschen gibt die\ndieses Package mit Freude verwenden, wo es gute Ergebnisse liefert und \nalle glücklich macht. Doch \"Ungleich\" Bedingungen werden von diesen Software \nPaketen gleichermaßen gehasst.\n\nUm einmal im Detail darzustellen wonach man eigentlich sucht, \ndefinieren wir im nächsten Abschnitt die Nebenbedingungen. \n\n\n## Buchstabensumme \n\nDie erste Nebenbedingung ist die offensichtlichste, da sie explizit gegeben ist.\nWie schon oben beschrieben ist jeweils die Summe der Buchstabe der einzelnen\nWörter gegeben. Man kann sich das ganze auch als eine Matrix vorstellen: Jede\nSpalte stellt einen Buchstaben dar (wie unten in der $n \\times l$ Matrix). \nDie erste Spalte ist **a** die zweite\nSpalte **b** und so weiter. Beim ersten Wort **ACDC** sehen wir eine **1** \nin der ersten Spalte (A), eine **2** in der dritten Spalte (C) und wieder eine\n**1** in der vierten Spalte (D) $\\rightarrow$ zusammen \nACDC^[oder ACCD -- beim Summieren ist die Reihenfolge ja völlig egal.]. \nJede Zeile stellt ein Wort, in diesem konkreten Fall eine Band dar.\nD. h. wir haben **n Wörter** und **l Buchstaben**^[Das sind immer 26 Buchstaben. Also könnte man auch 26 schreiben. Aber mit **l** schaut es viel cooler aus.].\nMultipliziert wird diese Matrix mit einem Vektor $\\vec{\\theta}$. Dieser beinhalten\ndas was man wissen will: die Werte der einzelnen Buchstaben. $\\theta_a$ ist \nder Wert den Buchtabe **a** hat. Die Werte kennen wir nicht. Das ultimative\nZiel ist es sie zu ermitteln. Wenn wir die $n \\times l$ Matrix mit $\\vec{\\theta}$\nmultiplizieren, muss die vorgegeben Summe rauskommen. Das sind genau die \nSummen die im Logical vorgegeben sind: Für **ACDC** z. B. **45**.\nDas schaut alles mega kompliziert aus. Das ist aber noch die netteste Nebenbedngung.\nDie kann ich auch an `SCIP` verfüttern. Aber die kommende Nebenbedingung ist\nschon schwieriger umzusetzen^[Vor allem wenn man eben ein Tool verwendet, das man eigentlich für ein solches Problem nicht verwenden sollte.].\n\n\\begin{align}\n\n\\begin{bmatrix}\n  1 & 0 & 2 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  1 & 1 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  0 & 0 & 0 & 1 & 3 & 0 & 0 & 0 & 0 & 0 & \\ldots \\\\\n  1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 2 & 0 & \\ldots \\\\\n  \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\\\\n\\end{bmatrix}\n\n_{n \\times l} \\times \\quad \\begin{bmatrix}\n   \\theta_a  \\\\\n   \\theta_b \\\\\n   \\theta_c \\\\\n   \\theta_d \\\\\n   \\theta_e \\\\\n   \\vdots\n\\end{bmatrix}_{l \\times 1} = \\quad\n\\begin{bmatrix}\n   45  \\\\\n   52 \\\\\n   62 \\\\\n   27 \\\\\n   82 \\\\\n   \\vdots\n\\end{bmatrix}_{l \\times 1}\n\\end{align}\n\n\n## Verschiedene Elemente\n\n<img src=\"media/memes/worst_constraint.jpg\" alt=\"My brain when solving a logical\" style=\"float: right; width: 35%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nWenn man sich obenstehende Tabelle ansieht, dann merkt man, dass man 26 Buchstaben\nhat, aber nur 20 Nebenbedingungen. Daher kann das nicht alles sein. Es darf nicht\nalles sein, wenn wir das hier lösen wollen. Die implizite Nebenbedingung ist, dass\njeder Buchstabe eine eigene Zahl zwischen 1 und 26 bekommen soll. Keine zwei\nElemente dürfen ident sein. Also etwas formeller angeschrieben sieht das ca. so aus:\n\n\n\\begin{align}\n1 \\leq \\theta_i \\leq 26, & \\quad i = a, b, \\ldots, z, \\\\\n\\theta_i \\neq \\theta_j, & \\quad \\forall i, j \\in \\{a, b, \\ldots, z\\}, i \\neq j.\n\\end{align}\n\nFür mich schien es das Naheliegendste das Problem mit Integer Programming zu lösen.\nDie Suche und das Herumprobieren war noch wesentlich unlustiger\nals das Ganze per Hand zu lösen. Ein sanfter Hinweis eines guten Freundes, \nließen mich verstehen: Es war eine Sackgasse und ich musste irgendwas mit \nPython machen. Was schlimmer war ließ sich in diesem Moment noch nicht entscheiden.\nEr schickte mir [seine Lösung](https://cocalc.com/haraldschilly/ideas/rockbands) \nund empfahl mir die Google [OR-Tools](https://developers.google.com/optimization?hl=en)\nzu verwenden wenn ich das Problem lösen will.\n\nAlso begann ich mit Python und den OR-Tools.\n\n## OR-Tools\n\n\n<img src=\"media/memes/oneline.jpg\" alt=\"Oneline\" style=\"float: right; width: 40%; margin-left: 20px; margin-bottom: 10px;\"/>\n\nDer Witz ist, dass sich dieses Problem mit **Constraint Optimization** sehr \neffizient lösen lässt. In unserem Beispiel haben wir nicht mal eine Zielfunktion.\nWir wollen einfach eine Lösung die alle Nebenbedingungen erfüllt, und gehen davon\naus, dass es nur eine Lösung gibt $\\rightarrow$ fertig. [Hier ist ein einfacheres\nBeispiel dazu.](https://developers.google.com/optimization/cp/cp_example) \nDem Solver von `ortools` mitzuteilen, dass jeder Buchstabe einer\nanderen Zahl zugeordnet werden soll, ist besonders einfach und ist unten im \nPython Code Block zu sehen: `model.AddAllDifferent(intvars)`. Das ist alles.\nKeine Tricks, keine Schleife die alle Variabenpaare ungleich setzen muss, einfach\ndieses Statement und der shit happened einfach so, als wäre es das einfachste der Welt.\nDas Ganze hab ich in 2 Funktionen gegossen. Wer sich diese im Detail ansehen will,\nbittesehr -- einfach unfolden:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom ortools.sat.python import cp_model\nimport pandas as pd\nimport numpy as np\nimport string\nimport os\n\n## Funktion um die Matrix zu erstellen\ndef create_letter_matrix(word_sum):\n    #word_sum = pd.read_excel(word_sum_file)\n\n    # es wird eine lettermatrix erstellt.\n    # zeilen sind die NB, spalten sind die Buchstaben\n    anz_zeilen = word_sum.shape[0]\n    letter_matrix = np.zeros((anz_zeilen,26),dtype=int)\n\n    # letter zu pos. DataFrame\n    letter_pos = pd.DataFrame({\n    'position': range(0, 26),\n    'buchstaben': list(string.ascii_lowercase)\n    })\n\n# matrix befuellen\n    woerter = word_sum[\"words\"].apply(lambda x: x.replace(\" \", \"\").lower()).tolist()\n    for zei, val in enumerate(woerter):\n        for i, letval in enumerate(val):\n            pos_spalte = letter_pos[letter_pos[\"buchstaben\"] == letval][\"position\"]\n            if not pos_spalte.empty: # das kam von chatGPT\n                letter_matrix[zei,pos_spalte.iloc[0]] += int(1)\n\n    return letter_matrix\n\n\n## Funktion um das Ganze zu solven\ndef solve_logical(word_sum_file = \"word_sum_input.csv\", outfile = \"loesung.csv\"):\n\n    # word sum - hier sind die wörter plus die summen drinnen!\n    #word_pd = pd.read_excel(word_sum_file)\n    word_pd = pd.read_csv(word_sum_file)\n    wordsum = word_pd[\"letter_sum\"].tolist()\n    letters = list(string.ascii_lowercase)\n\n    # eine matrix wird erstellt, wie haeufig jeder buchstabe in einem wort vorkommt\n    letter_matrix = create_letter_matrix(word_sum = word_pd)\n    \n    # optimieren\n\n    model = cp_model.CpModel()\n\n    intvars = np.array([])\n    for i, val in enumerate(letters):\n        intvars = np.append(intvars, model.NewIntVar(1, 26, val))\n    \n    # alle muessen unterschiedlich sein\n    model.AddAllDifferent(intvars)\n\n    # nebenbedingungen - summe der buchstaben der woerter als matrixmultiplikation\n    res_sum = letter_matrix @ intvars\n\n    for i, val in enumerate(res_sum):\n        model.Add(val == wordsum[i])\n\n    solver = cp_model.CpSolver()\n    status = solver.Solve(model)\n\n    # rausspeichern\n    res_dat = []\n    for i in intvars:\n        res_dat.append(solver.Value(i))\n\n    loesung = pd.DataFrame({'Buchstabe': letters, 'value':  res_dat})\n\n    data = {\"Loesung\": [loesung.columns.tolist()] + loesung.values.tolist()}\n    loesung.to_csv(outfile)\n\n    return data\n```\n:::\n\n\n\nNicht jeder hat jetzt vielleicht die Lust Python zu installieren bzw. die \nnotwendigen Packages, will aber trotzdem das Beispiel ausprobieren bzw. sein\neigenes Logical lösen. Dazu kommen wir im nächsten Abschnitt!\n\n\n# Die Lösung\n\nUm das Problem zu lösen brauchen wir mal ein Inputfile.\n\n::: {.callout-tip icon=false}\n## {{< bi save size=25px >}} Input File\n\n**Wie muss das Input .csv aussehen?**\n\n- Es muss ein csv sein mit \",\" (Beistrich) als seperator\n- Es muss eine Spalte mit dem Namen `words` beinhalten in dem die **Wörter** angeführt sind\n- Es muss eine Spalte mit den **Buchstabensummen** namens `letter_sum` beinhalten \n\nHier ist das [.csv File](media/word_sum_input.csv) für genau das hier dargestellte Problem.\n:::\n\nDann brauchen wir 2 Funktionen:\n\n1. Eine Funktion die aus den Wörtern eine Matrix macht wie oben gezeigt\n2. Eine Funktion die die Nebenbedingungen formuliert und die Lösung errechnet\n\n\nDas alles soll \"Out of the box\" funktionieren -- daher verwenden wir ein, \ngenau für diesen Zweck erstelltes, Docker Image. Es beinhaltet die Python\nFunktionen und kann wie folgt aufgerufen werden.\nWichtig ist, dass [Docker am Computer installiert ist!](https://docs.docker.com/engine/install/)\n\n\n```{.bash filename=\"Terminal\"}\n# eventuell muss vor jeden Befehl ein sudo\n# pull image\ndocker pull seebaer/logical-python\n\n# check: es sollte das gerade gepullte image aufgelistet sein\ndocker image ls\n\n# word_sum_input.csv wird an docker übergeben\ndocker run -v /home/USER/logical:/data seebaer/logical-python python logical_python_functions.py --word_sum_file /data/word_sum_input.csv --outfile /data/result.csv\n```\n\nWas passiert hier?\n\n1. Es wird ein Docker image von Docker Hub gezogen (`docker pull ...`). Dieses Image wurde speziell\nfür diesen Zweck gebaut. Es beinhaltet ein minimales Linux, Python und die Python Funktionen\ndie notwendig sind um das Problem zu lösen.\n2. Wenn das Image am Computer ist (Kontrolle mit: `docker image ls`) kann man es\nlaufen lassen.\n    - `docker run` lässt das gerade gezogene image laufen (`logical_img`)\n    - `-v /home/USER/logical:/data` mounted mein Verzeichnis `/home/USER/logical`\n    in das Verzeichnis des docker container `/data` $\\rightarrow$ in diesem Verzeichnis\n    muss sich die Datei: `word_sum_input.csv` befinden!\n    - Ausgeführt wird das Skript das sich im Container befindet: `python logical_python_functions.py`\n    - Input ist eben das .csv file: `--word_sum_file /data/word_sum_input.csv` das in `/data` liegt, also\n    bei uns in `/home/USER/logical`^[Oder in einem anderen beliebigen Verzeichnis!]\n    - Wohin soll der Output **gespeichert** werden und wie soll der output heißen? \n    Das wird hier angegeben: `--outfile /data/loesung_docker.csv`\n\n\n\n<br>\n\nDamit wurde das Problem gelöst. Es erklingt fröhliche Schlussmusik. \nEs hat lang gedauert. Es wäre wohl schneller gewesen\nhätte ich es per Hand gelöst. Dafür hab kann nun jeder in Zukunft Probleme dieser\nArt im Handumdrehen lösen: Dank Python und Docker.\n\n\n::: {style='text-align:center;'}\n![](media/whale_python.webp){width=20%}\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.28/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.4/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.4/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.4/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}